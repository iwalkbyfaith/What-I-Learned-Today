# Chapter6. 클래스 (p.212~)

## 🔴 6-1 객체 지향 프로그래밍

<br>

### ⬛ 객체
- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 `자신의 속성`을 가지고 있으면서 `식별 가능`한 것.
- 속성(필드 field)과 동작(메소드 method)로 구성된다.

<br>

### ⬛ 객체의 상호작용
- 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작한다.
- 객체들 사이의 상호작용 수단은 메소드이다.
- 객체가 다른 객체의 기능을 이용하는 것이 메소드 호출이다.
- 예시) 리턴값 = 객체.메소드(매개값1, 매개값2, … );
	- 1) 객체에 도트(.) 연산자를 붙이고 메소드 이름을 기술한다. 도트 연산자는 객체의 필드와 메소드에 접근할 때 사용한다.
	- 2) 매개값은 메소드를 실행하기 위해 필요한 데이터이다. 리턴값은 메소드가 실행되고 난 후 호출한 곳으로 돌려주는(리턴하는) 값이다.

<br>

### ⬛ 객체 간의 관계
- 객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다.
- 관계의 종류
	- 집합 관계 : 하나는 부품이고 하나는 완성품 ( 자동차 – 엔진, 타이어 ..)
	- 사용 관계 : 객체 간의 상호작용 ( 사람 – 자동차 )
	- 상속 관계 : 상위(부모)객체를 기반으로 하위(자식) 객체를 생성 ( 기계 – 자동차 )

<br>

### ⬛ 객체와 클래스
- `클래스` : 자바에서의 설계도. 객체를 생성하기 위한 필드와 메소드가 정의 되어있다.
- `인스턴스` : 클래스로부터 만들어진 객체.  “객체는 클래스의 인스턴다”
- (예시) 자동차 객체는 자동차 클래스의 인스턴스
- 인스턴스화 : 클래스로부터 객체를 만드는 과정

<br>

### ⬛ 클래스 선언
- `식별자 작성 규칙`  

![image](https://user-images.githubusercontent.com/93142964/178175264-0b8d2749-586c-4f2f-9084-69d8b6abf462.png)



- 🔥 순서
	- 1. 클래스 이름을 정한 후, 클래스이름.java로 소스 파일을 생성한다.
	- 2. 소스 파일 이름 역시 대소문자를 구분하므로 반드시 클래스 이름과 대소문자가 같도록 해야한다.
	- 3. 소스 파일을 생성하면 소스 파일을 열고 클래스를 선언한다.
		- public class 클래스이름 {}
		- public class 키워드는 클래스를 선언할 때 사용하며 반드시 소문자로 작성한다.

	- 4. 일반적으로 소스파일당 하나의 클래스를 선언한다. 하지만 2개 이상의 클래스 선언도 가능하다.
		- (참고) 2개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일(.class)은 클래스를 선언한 개수만큼 생긴다. 결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다.
		- (예시) 하나의 소스 파일 안에 public class Car{} class Tire{}를 선언한 경우
			-> 상기 코드를 컴파일하면 Car.class와 Tire.class가 각각 생성된다.


<br>

### ⬛ 객체 생성과 클래스 변수
- 클래스로부터 객체를 생성하려면 <b>`new 연산자`</b>를 사용해야한다.

```java
new 클래스이름();
```

-
    - new는 클래스로부터 객체를 생성시키는 연산자이다.
    - new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
    - new 연산자로 생성된 객체는 메모리 힙 영역에 생성된다.
    - new 연산자는 <b>힙 영역에 객체를 생성시킨 후, 객체의 번지를 리턴</b>하도록 되어있다. 이 주소를 참조 타입인 클래스 변수에 저장해두면 변수를 통해 객체를 사용할 수 있다.

<br>

- ◾ 클래스의 용도
	- 클래스는 두 가지 용도가 있다.
	- `라이브러리 클래스` : 다른 클래스에서 이용할 목적으로 설계됨
	- `실행 클래스` : 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할


<br>


### ⬛ 클래스의 구성 멤버

```java
public class ClassName{

	// 필드
	int fieldname;

	// 생성자
	ClassName(){ … }

	// 메소드
	void methodName(){ … }

}
```

- 필드 Field
	- 객체의 데이터(고유 데이터, 부품 객체, 상태 정보)가 저장되는 곳
	- 선언 형태는 변수(variable)와 비슷하지만, 필드를 변수라고 부르지는 않는다.
		- <b>변수</b> : 생성자와 메소드 내에서만 사용되고, 생성자와 메소드가 실행 종료되면 자동 소멸됨
		- <b>필드</b> : 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재함.

<br>

- 생성자 Constructor
	- 객체 생성 시 초기화 역할 담당
	- new 연산자로 호출되는 특별한 중괄호{} 블록
	- 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다.
	- 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없다.

<br/>

- 메소드 Method
	- 객체의 동작에 해당하는 실행 블록.
	- 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
	- 객체 간의 데이터를 전달하는 수단이다. 외부(호출한 곳)로부터 매개값을 받아 실행에 사용하고, 실행 후 결과 값을 외부(호출한 곳)로 리턴 할 수도 있다.


<br><br><hr>

## 🔴 6-2 필드

<br>

### ⬛ 필드
- 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
- 자동차 객체에서는 (고유데이터) company, model / (상태데이터) speed / (부품) Body body, Tire tire 등이 해당된다.

<br>

### ⬛ 필드 선언
- 필드 선언은 클래스 중괄호 {} 블록 어디서든 존재할 수 있다.
- 하지만 생성자와 메소드 중괄호 {} 블록 내부에는 선언할 수 없다 => 로컬 변수로 취급

```java
타입 필드 [=초기값];
```
<br>

```java
String company = “현대”;
int maxSpped ;
```

- 
	- 타입은 필드에 저장할 데이터의 종류를 결정한다.
	- 타입에는 기본타입과 참조 타입이 모두 올 수 있다.
	- 초기값이 지정되지 않은 필드는 객체 생성 시 <b>자동으로 기본 초기값으로 설정</b>된다.


<br>

### ⬛ 필드 사용
- 필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말한다.
- 클래스 내부의 생성자나 메소드에서 사용할 경우 : 단순히 필드 이름으로 읽고 변경하면 됨
- 클래스 외부에서 사용할 경우 : 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 함
	- 필드가 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문
 

<br><br><hr>


## 🔴 6-3 생성자

<br>

### ⬛ 생성자
- new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당함.

<br>

### ⬛ 기본 생성자
- 모든 클래스는 생성자가 반드시 존재하며, 생성자를 <b>하나 이상 가질</b> 수 있다.
- 생성자 선언을 생략했다면, 컴파일러는 다음과 같이 중괄호{} 블록 내용이 비어있는 기본 생성자를 바이트 코드에 자동 추가한다.
```java
[public] 클래스() { }
```
- 클래스가 public class로 선언되면 기본 생성자에도 public이 붙는다.
- 컴파일러가 생성자를 자동으로 추가해주기 때문에, 클래스에 생성자를 선언하지 않아도 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성할 수 있다.
- (<span style='color:red'>중요</span>) 클래스에 명시적으로 선언한 생성자가 1개라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다.

<br>


### ⬛ 생성자 선언
```java
클래스( 매개변수선언, … ){

	// 객체의 초기화 코드

}
```

```java
public class Car{
	// 생성자
	Car(String model, String color){ … }
}
```

- 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다.
- 매개 변수 선언은 생략할 수도 있고 여러 개를 선언해도 된다.
- 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.

<br>

### ⬛ 필드 초기화
- 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.
- 다른 값으로 초기화 하고 싶은 경우는
	- 방법 1) 필드를 선언할 때 초기값을 준다 
	-> 동일한 클래스로 생성되는 객체들은 생성되는 시점에서 모두 같은 값을 갖게 됨
    ```java
    public class Korean{
        String nation= “대한민국”;
        String name;
    }
    ```
	- 방법 2) 생성자에서 초기값을 준다.
		- 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면, 생성자에서 해야한다.
		- 생성자의 매개값으로 이 값들을 받아야 한다.
    ```java
        Korean k1 = new Korean(“김만두”);
    ```
<br>

- ◾ 생성자의 매개 변수 이름
	- 매개 변수의 이름이 너무 짧으면 코드의 가독성이 좋지 않다.
	- 초기화시킬 필드 이름과 비슷하거나 `동일한 이름`을 사용하는 것이 좋다.
	- (🔥문제 발생) 이 경우 필드와 매개 변수 이름이 동일하리 때문에 생성자 내부에서 해당 필드에 접근할 수 없다.
		- 동일한 이름의 매개 변수가 사용 우선순위가 높기 때문
	- (🔥문제 해결) 필드 앞에 ‘this.’을 붙이면 된다.
		- `this`는 객체 자신의 참조. 객체가 객체 자신을 this라고 한다.
		- this.필드 는 this라는 참조 변수로 필드를 사용하는 것과 동일하다.
        ```java
        public Korean(String name, String ssn){
            this.name = name;
            this.ssn = ssn;
        }
        ```
		- name과 ssn은 매개 변수, this.name과 this.ssn는 필드


<br>

### ⬛ 생성자 오버로딩
- 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면, 생성자도 다양화될 필요가 있다.
- 자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공한다.
- 생성자 오버로딩이란 <b>매개 변수를 달리하는 생성자를 여러 개 선언하는 것</b>을 말한다.

<br>

```java
public class Car{
	Car() { … }
	Car(String model){ … }
	Car(String model, String color){ … }
}
```

<br>

- (🔥 주의) 매개 변수의 타입과 개수, 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.


<br>

### ⬛ 다른 생성자 호출 : this()
- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다.
- 🔥 이 경우에는 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고, 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법을 사용하면 된다.
- 생성자에서 다른 생성자를 호출할 때에는 this() 코드를 사용한다.
```java
Car(String model){
	this(model, “은색”, 250);
}

Car(String model, String color){
	this(model, color, 250);
}

Car(String model, String color, int maxSpeed){
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
```



<br><br><hr>
## 🔴 6-4 메소드

<br>

### ⬛ 메소드
- 메소드 선언은 선언부(메소드 시그너처)와 실행 블록으로 구성된다.
	- `리턴 타입` : 메소드가 리턴하는 결과의 타입
	- `메소드 이름` : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어준다.
	- `매개 변수 선언` : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언
	- `메소드 실행 블록` : 실행할 코드 작성

```java
리턴타입 메소드이름 ( 매개변수선언, … ) {
	
	// 메소드 실행 블록

}
```


<br>

### ⬛ 메소드 선언
- 메소드 선언은 선언부(리턴 타입, 메소드 이름, 매개 변수 선언)와 실행 블록으로 구성된다.

- ◾ `리턴 타입`
	- 리턴 값의 타입
	- 리턴 값 = 메소드를 실행한 후의 결과값
	- 리턴 값이 있을 수도 있고, 없을 수도 있다
	- 리턴 값이 있느냐 없느냐에 따라 메소드를 호출하는 방법이 다르다.
		- 리턴 값이 있는 경우 : 변수에 저장해야 할 내용이 있으므로 변수로 받아준다. (호출만 하는 경우에는 필수는 아님)
		- 리턴 값이 없는 경우 : 단순히 메소드만 호출한다.

<br>

- ◾ `메소드 이름`
	- 자바 식별자 규칙에 맞게 작성한다. (위의 표 참고)
	- 관례적으로 메소드 이름은 소문자로 작성한다.

<br>

- ◾ `매개 변수 선언`
	- 매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다.
	- 매개 값은 반드시 매개 변수의 타입에 부합하는 값이어야 한다.
		- int 타입 매개 변수의 경우는 매개값으로 int값이나 int 타입으로 변환될 수 있는 값을 넘겨주어야 한다.

<br>

- 매개 변수의 개수를 모르는 경우
	- 방법1) 매개 변수를 배열 타입으로 선언
        ```java
        int sum1(int[] values) { … }
        ```
        ```java
        int[] values = { 1, 2, 3 };
        int result = sum1(values);
        int result = sum1(new int[] { 1, 2, 3, 4 });
        ```
		- (문제 발생) 매개 변수를 배열 타입으로 선언하면 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.
		- (문제 해결) 배열을 생성하지 않고 값의 목록만 넘겨준다. <br><br>

	- 방법2) 매개 변수를 ...을 사용해서 선언
        ```java
        int sum2(int … values){ … }
        ```
        ```java
        int result = sum2( 1, 2, 3, 4 );
        int[] values = { 1, 2, 3 };
        int result = sum2(values);
        int result = sum2(new int[] { 1, 2, 3, 4, 5 });
        ```

<br>

### ⬛ 리턴문
- ◾ 리턴값이 있는 메소드
	- 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 한다.
	- 만약 return문이 없다면 컴파일 에러가 발생하고, `return문이 실행되면 메소드는 즉시 종료`된다.
	- <b>return문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 한다.</b>
		- 예시) 리턴 타입이 int인 경우 byte, short가 리턴되어도 자동 타입 변환으로 int가 됨 <br><br>

- ◾ 리턴값이 없는 메소드 : void
	- 리턴값이 없는 메소드는 리턴 타입으로 void를 사용한다.
	- <b>void로 선언된 메소드</b>에서도 return문을 사용할 수 있는데, 이때는 `메소드 실행을 강제 종료` 시키는 역할을 한다.


<br>

### ⬛ 메소드 호출
- `클래스 내부`에서 호출할 경우 : 단순한 메소드 이름으로 호출 가능
- `클래스 외부`에서 호출할 경우 : 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출한다.
	- 객체가 존재해야 메소드도 존재하기 때문

<br>

- ◾ 객체 내부에서 호출
    ```java
    메소드 ( 매개값, … );
    ```

    ```java
    method1( “김만두”, 2 );
    ```

<br>

- ◾ 객체 외부에서 호출
    ```java
    클래스 참조변수 = new 클래스( 매개값, … );
    ```

<br>

### ⬛ 메소드 오버로딩
- 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
- 오버로딩Overloading: 과적 => 하나의 메소드 이름으로 여러 기능을 담는다고 해서 붙여진 이름.
- 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서 사용
- (🔥 조건) 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다는 점.

```java
class 클래스{
	리턴타입 메소드이름 (타입 변수, … ) { … }
	리턴타입 메소드이름 (타입 변수, … ) { … }
}
```
- 
	- 리턴 타입 : 달라도 상관 없음
	- 메소드 이름 : 동일해야 함.
	- 타입 변수 : 타입, 개수 순서가 달라야 함.

<br><br>

- Q) plus(double값, double값); 을 넣어야 하는 곳에 plus(int, double); 값을 넣으면 컴파일 에러가 날까?
- A) No
	- plus(double x, double y) 메소드가 실행이 된다.
	- JVM은 일차적으로 매개 변수의 타입을 보지만, 매개 변수의 타입이 일치하지 않을 경우 자동 타입이 변환 가능한지 검사를 한다.
	- int는 double로 변환이 가능하므로 최종적으로는 plus(double, double); 이 진행 되는 것

<br>

- 🔥 메소드 오버로딩시 주의점
	- 1. 매개 변수의 타입과 개수, 순서가 똑같을 경우 ‘매개 변수 이름’이 다르다고 해서 오버로딩이 아니다.
	- 2. 리턴 타입만 다르고 매개 변수가 동일하다면 오버로딩이 아니다.
		- 리턴 타입은 JVM이 메소드를 선택할 때 아무런 도움을 주지 못한다.
 

 
<br><br><hr>

## 🔴 6-5 인스턴스 멤버와 정적 멤버

- 클래스는 객체의 설계도이다. 클래스 멤버(필드, 메소드)는 당연히 객체에도 포함되어야 있어야 한다.
- (의문) 그런데 과연 이것이 효율적인가? 클래스로부터 객체(인스턴스)가 둘 이상이 만들어질 때, 클래스 멤버들을 객체마다 모두 가지고 있을 필요가 있을까?
- 객체마다 필드 값이 달라야 하는 경우 말고, 모두 같아야 하는 경우에는, 필드를 객체마다 각각 가지고 있는 것은 메모리 낭비이다. 
	- (결론) 이런 필드는 한 곳에 위치시키고 객체들이 공유하는 것이 좋을 수도 있다.

<br>

- `인스턴스 멤버` : 객체마다 가지고 있는 멤버
- `정적 멤버` : 클래스에 위치시키고 객체들이 공유하는 멤버

<br>

### ⬛ 인스턴스 멤버와 this
- 객체(인스턴스)를 생성한 후 사용할 수 있는 필드(인스턴스 필드)와 메소드(인스턴스 메소드)
- 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다.
- 외부 클래스에서 사용하기 위해서는 객체를 생성하고 참조 변수를 통해 접근해야 한다.

<br>

- ◾ 인스턴스 멤버 선언
```java
public class Car {
	// 필드
	int gas;

	// 메소드
	void stepped(int spped) { … }
}
```

<br>

- ◾ `this`
	- 객체 내부에서 인스턴스 멤버에 접근하기 위해 this를 사용한다.
	- this.model : 자신이 가지고 있는 model 필드라는 뜻
	- this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 사용.


<br>

### ⬛ 정적 멤버와 static
- 🔥 정적 멤버는 <b>클래스에 고정</b>된 멤버로서, <b>객체를 생성하지 않고 사용</b>할 수 있는 필드(정적 필드)와 메소드(정적 메소드)이다.

<br>

- ◾ 정적 멤버 선언
	- 필드와 메소드 선언시 static 키워드를 붙여주면 된다.
	```java
	public class 클래스{
		// 정적 필드
		static 타입 필드 [=초기값];
		
		// 정적 메소드
		static 리턴타입 메소드( 매개변수선언, … ) { … }
	}
	```
	- 🔥 정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로, 클래스로더가 클래스(바이트코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.

<br>

- ◾ 정적 멤버 사용
	- 클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있다.
	- 클래스 이름과 함께 도트(.) 연산자로 접근한다.
	- 객체 참조 변수로도 접근 가능하지만, 원칙적으로 클래스 이름으로 접근하는 것이 좋다.
    <br><br>

	```java
	클래스.필드;
	클래스.메소드 ( 매개값, … );
	```

<br>

- ◾ <b>정적 메소드 선언시 주의할 점</b>
	- 객체가 없어도 실행되기 때문에, 정적 메소드 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.
	- 또한 객체 자신의 참조인 this 키워드도 사용 불가능하다.
	- 정적 메소드에서 인스턴스 멤버를 사용하고 싶다면, 메소드 내에서 new 연산자로 객체를 생성하고 참조 변수로 접근해야 한다. (main 메소드에서도 동일)

<br>

### ⬛ 싱글톤
- 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우, `단 하나만 생성되는 객체`를 싱글톤이라고 한다.

- 1. 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.
	    - 생성자를 호출한 만큼 객체가 생성되기 때문
	    - 생성자 앞에 private 접근 제한자를 붙여주면 된다.
- 2. 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다.
	    - 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다.
	    - 정적 필드도 private 접근 제한자를 붙여서 외부에서 필드값을 변경하지 못하도록 막는다.
- 3. 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.
	    - 외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출하는 방법이다.
	    - getInstance() 메소드는 단 하나의 객체만 리턴하기 때문에 다른 변수에 저장해도 동일한 객체를 참조한다.

<br>
- 코드

```java
public class 클래스{
	// 정적 필드
	private static 클래스 singleton = new 클래스();

	// 생성자
	private 클래스() {}

	// 정적 메소드
	static 클래스 getInstance(){
		return singleton;
	}
}
```


<br>

### ⬛ final 필드와 상수

- ◾ final 필드
	- `초기값이 저장`되면 이것이 `최종적인 값`이 되어서 프로그램 실행 도중 <b>수정할 수 없다.</b> <br>

    ```java
    Final 타입 필드 [=초기값];
    ```

	- final 필드의 초기값을 주는 방법
		- 방법1) 필드 선언시에 주기 : 단순 값
		- 방법2) 생성자에서 주기 : 복잡한 초기화 코드가 필요하거나, 객체 생성시에 외부 데이터로 초기화하는 경우

	- 생성자는 final 필드의 최종 초기화를 마쳐야 하는데, 만약 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.

<br>

- ◾ 상수 constant
	- 불변의 값(static final)

	- Q) final 필드와 상수의 차이점은?
	- A) 상수는 객체마다 저장할 필요가 없는 공용성을 띠고 있으며, 여러가지 값으로 초기화 될 수 없다.   
    반면 final 필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러가지 값을 가질 수 있기 때문에 상수가 될 수 없다.

	- 상수는 static 이면서 final이어야 한다.
	- static final은 필드는 객체마다 존재하지 않고 클래스에만 존재한다. 그리고 한 번 초기값이 저장되면 변경할 수 없다.

    ```java
    static final 타입 상수 = 초기값;
    ```
	- 상수 이름은 모두 대문자로 작성하는 것이 관례이다.
	- 만약 서로 다른 단어가 혼합된 이름이라면 언더바(_)로 연결한다.

    ```java
    Static final double EARTH_RADIUS = 6400;
    ```



<br><br><hr>
## 🔴 6-6 패키지와 접근 제한자

<br>

### ⬛ 패키지
- 패키지는 단순 파일 시스템의 폴더 기능만 하는 것이 아니라, <b>클래스의 일부분<b>으로 <b>클래스를 유일하게 만들어주는 `식별자` 역할</b>을 한다.
- 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식한다.
- 클래스의 전체 이름은 ‘패키지 이름 + 클래스 이름’인데, 패키지가 상/하로 구분되어 있다면 도트(.)를 사용해서 표현한다.
```java
상위패키지.하위패키지.클래스
```

<br>

### ⬛ 패키지 선언
- 클래스를 작성할 때 해당 클래스가 어떤 패키지에 속할 것인지 선언해야한다.

```java
package 상위패키지.하위패키지;

public class ClassName { … }
```

- ◾ 패키지 이름을 지을 시 규칙
	- 숫자로 시작해서는 안되고, _와 $를 제외한 특수문자를 사용하면 안된다.
	- java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안된다
	- 모두 소문자로 작성한다 (관례)  

<br>

- ◾ import 문
	- 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면, import문으로 해당 패키지의 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에게 알려주어야 한다.

    ```java
    import 상위패키지.하위패키지.클래스이름;
    import 상위패키지.하위패키지.*;
    ```

	- import문은 패키지 선언과 클래스 선언 사이의 작성한다.
	- 사용하고자 하는 클래스들이 동일한 패키지라면 *를 이용한다.
	- import문은 개수에 제한이 없고 얼마든지 추가할 수 있다.
    <br><br>

	- (주의1) 상위 패키지를 import 했다고 해서 하위 패키지까지 import 되는 것은 아니다.
		- 자바는 패키지 전체 이름으로 패키지를 식별하기 때문에
			- com.ict 와 com.ict.project를 서로 다른 패키지로 인식한다. <br><br>

	- (주의2) import문과 상관없이 패키지가 포함된 클래스 전체 이름을 코드에 기술해야 하는 경우가 있다.
		- 서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지가 모두 import 된 경우.
		- 컴파일러는 어떤 패키지의 클래스를 사용해야 할지 모호해지므로 컴파일 에러를 발생시킨다.
		- (해결) 정확하게 패키지가 포함된 클래스 전체 이름을 기술해야 한다.
		```java
		sec06.exam02.hankook.Tire tire3 = new sec06.exam02.hankook.Tire();
		sec06.exam02.Kumho.Tire tire4 = new sec06.exam02.Kumho.Tire();
		```

<br>

### ⬛ 접근 제한자
- 접근을 제한하기 위해 사용.
- 클래스 및 인터페이스, 멤버에 대한 접근을 의미한다.

<br>

- 1. public 접근 제한자 : 외부 클래스가 자유롭게 사용할 수 있음
- 2. protected 접근 제한자 : 같은 패키지 또는 자식 클래스에서 사용할 수 있음
- 3. default 접근 제한 : 위 세 가지 접근 제한자가 적용되지 않으면 default 접근 제한을 가진다. 같은 패키지에서만 사용 가능.
- 4. private 접근 제한자 : 외부에서 사용할 수 없음.

<br>

### ⬛ 클래스의 접근 제한
![image](https://user-images.githubusercontent.com/93142964/178182683-8076e585-4c6b-4622-a57d-a1be00b29194.png)


<br>

### ⬛ 생성자의 접근 제한
![image](https://user-images.githubusercontent.com/93142964/178182741-82d3f176-37f3-429d-8793-4a10d3470283.png)

<br>

### ⬛ 필드와 메소드의 접근 제한
- 필드와 메소드를 선언할 때, 
    - 해당 필드와 메소드를 클래스 내부에서만 사용할 것인지,
    - 패키지 내에서 사용할 것인지, 
    - 다른 패키지에서도 사용할 수 있도록 할 것인지 결정한다.

```java
// 필드 선언
[ public | protected | private ] [static] 타입 필드;

// 메소드 선언
[ public | protected | private ] [static] 리턴타입 메소드(매개변수){ … } ;
```
<br>

![image](https://user-images.githubusercontent.com/93142964/178182827-556912c4-6984-49a4-afe7-b0e09a3aefe9.png)


 





