# Chapter5. 참조 타입 (p.164~)  


## 🔴 5-1 참조 타입과 참조 변수
<br>

### ⬛ 자바의 타입
- 기본 타입 : 정수, 실수, 문자, 논리 리터럴을 저장하는 타입
- 참조 타입 : 배열, 열거, 클래스, 인터페이스 등 객체의 번지를 참조하는 타입

<br>

⬛ 기본 타입과 참조 타입
- 기본 타입으로 선언된 변수와 참조 타입으로 선언된 변수의 차이점은 `저장되는 값`이다.
- 기본 타입 변수는 실제 값을 `변수 안`에 저장하지만, 참조 타입 변수는 `메모리의 번지`를 변수 안에 저장한다.
- 번지를 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부르는 것.

<br>

⬛ 메모리 사용 영역
- ◾ JVM이 사용하는 메모리 영역
	- 1. 메소드 영역
		- JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역
		- 코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 정적 필드(static field)와 상수(constant), 메소드 코드, 생성자 코드 등을 분류해서 저장한다.

    <br>

	- 2. 힙 영역
		- 객체와 배열이 생성되는 영역
		- 여기에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
		- 만약 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 JVM에서 이것을 쓰레기로 취급하고 쓰레기 수집기(Garbage Collector)를 실행시켜 자동으로 제거한다. 

    <br>

	- 3. JVM 스택 영역
		- 메소드를 호출할 때마다 프레임을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.
		- 스택 영역에 변수가 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 저장될 때이다.
		- 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.
        - ![image](https://user-images.githubusercontent.com/93142964/177893505-4f46482b-0e5f-4fe1-a9a9-aaa83adc0f66.png)
            - `스택(STACK)`은 쌓아 올린다는 의미로 데이터를 차곡차곡 쌓아 올린 형태의 자료 구조이다.
            - 스택은 `LIFO(Last in First Out)` 방식으로, 말 그대로 가장 마지막에 삽입된 자료가 가장 먼저 삭제 된다고 하여 "후입 선출" 구조라고 한다.

<br><br>


<br>


### ⬛ 참조 변수의 ==, != 연산
- 기본 타입 변수의 ==, != 연산 : `변수의 값`이 같은지 아닌지를 조사
- 참조 타입 변수의 ==, != 연산 : `동일한 객체`를 참조하는지, 다른 객체를 참조하는지를 조사
- 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 ==, != 연산은 결국 `번지 값을 비교하는 것`이다.
	- 동일한 번지 값을 같고 있다는 것은? 동일한 객체를 참조한다는 의미!

<br>

- ![image](https://user-images.githubusercontent.com/93142964/177893579-4e6fbf68-1e63-408e-828d-7a6398f9e9c6.png)
	- refVar1 == refVar2  ( 결과 : false )
	- refVar1 != refVar3   ( 결과 : true )


<br><br>

### ⬛ null과 NullPointerException
- 🔥 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null(널) 값을 가질 수 있다.
- 🔥 null값도 초기값으로 사용할 수 있기 때문에, null로 초기화된 참조 변수는 스택 영역에 생성된다.
- ◾ NullPointerException
	- 참조 타입 변수를 잘못 사용하면 발생한다.
	- 참조 변수가 null을 가지고 있을 경우에는, 참조 객체가 없으므로 변수를 통해 객체를 사용할 수 없다.
	- 만약 null 상태에서 있지도 않은 객체의 데이터(필드)나 메소드를 사용하는 코드를 실행하면 예외가 발생한다.
    - ![image](https://user-images.githubusercontent.com/93142964/177893690-151c4c3c-d996-4780-b64b-14362549509e.png)
        - intArray변수가 참조하는 배열 객체가 없음.
    <br><br>

    - ![image](https://user-images.githubusercontent.com/93142964/177893726-679282e2-39b1-41fe-afc7-a902f29f8d2a.png)
        - str 변수가 참조하는 String 객체가 없음

		- NullPointerException이 발생했을 때 해결 방법은 참조 변수를 추적해서 객체를 참조하도록 수정하는 것이다.

        <br><br>



<br>

### ⬛ String 타입
- 문자열은 String 객체로 생성되고, 변수는 String 객체를 참조한다.
- 자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어있다.
- 일반적으로 변수에 문자열을 저장할 경우에는 문자열 리터럴을 사용하지만, new 연산자를 사용해서 직접 String 객체를 생성시킬 수도 있다.
	- 🔥 (키워드) new 연산자 : 힙 영역에 새로운 객체를 만들 때 사용하는 연산자. 객체 생성 연산자라고도 부름.
<br><br>

- ![image](https://user-images.githubusercontent.com/93142964/177893839-296c086b-e7b8-46aa-946e-1a6bfde7813a.png)
    - str1과 str2는 같은 객체의 번지를 참조하고, str3는 새로 생긴 객체의 번지를 참조한다.
	- 따라서 객체 간의 비교에서 str1과 str2는 == 연산에서 true가 나오지만, str3과 비교할 때는 false가 나온다.
	- .equals를 사용해서 비교하면, 모두 “문자열”이라는 값을 가지고 있으므로 true가 나온다.


<br><br><hr><br>

## 🔴 5-2 배열

- `변수`는 `한 개의 데이터`만 저장할 수 있다.
- 저장해야 할 데이터의 수가 많아지면 그만큼 많은 변수가 필요하고 코드도 길어진다.
- 배열은 많은 양의 데이터를 적은 코드로 손쉽게 처리할 수 있도록 도와준다.

<br>

### ⬛ 배열이란?
- 같은 타입의 데이터를 연속된 공간에 나열하고, 각 데이터에 인덱스를 부여해놓은 자료 구조
- 특징
	- 1. 배열은 같은 타입의 데이터만 저장할 수 있다.
	    - 선언과 동시에 저장할 수 있는 타입이 결정되고, 다른 타입을 저장하려고 하면 타입 불일치 컴파일 에러가 발생함. <br><br>
	- 2. 한 번 생성된 배열은 <b>길이를 늘리거나 줄일 수 없다.</b>
		- 배열의 길이가 모자라면 새로운 배열을 생성하고, 기존 배열 항목을 새 배열로 복사해야 한다.

<br>

### ⬛ 배열 선언
- (형식1) 타입[] 변수;
	- int[] intArray;

- (형식2) 타입 변수[];
	- String strArray[];

<br>

- 배열도 객체이므로 힙 영역에 생성되고, 배열 변수는 힙 영역의 배열 객체를 참조한다.
- 참조할 배열 객체가 없다면 배열 변수는 null 값으로 초기화 될 수 있다.


<br>

### ⬛ 배열 생성
- (방법1) 값 목록 이용
	- 타입[] 변수 = { 값0, 값1, … 값10 } ;
	- 중괄호{} 는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴한다.
	- 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.
<br>

	- (🔥문제) 배열 변수를 이미 선언한 후에는 다른 실행문에서 중괄호를 사용한 배열 생성이 이루어지지 않음.
        - ![image](https://user-images.githubusercontent.com/93142964/177894115-cb256a83-1522-48cd-9228-655337ab7d0b.png)
            - 에러 메시지 : “배열 상수는 초기화에 사용할 수 있습니다.”
            - (해결) new 연산자를 사용해서 값 목록을 지정해주면 된다.
        
        <br>

        - ![image](https://user-images.githubusercontent.com/93142964/177894175-6a0c0809-8946-4c81-9161-922bfd72f916.png)
            - (주의) print시 ‘names’만 입력하면 주소값만 나오기 때문에 Arrays.toString(변수명) 사용.

<br><br>

- (방법2) new 연산자
    - 타입[] 변수 = new 타입[길이];
        - int[] intArray = new int[5];
        - 길이가 5인 int[] 배열 생성
        - new 연산자로 배열을 처음 생성할 경우 배열은 자동적으로 기본값으로 초기화됨.
        - 정수의 경우는 0, 실수는 0.0, 논리값은 false, 참조타입은 null
    - 배열을 생성 후, 특정 인덱스 위치에 대입연산자를 이용해서 값을 저장할 수 있음.
        - 변수[인덱스] = 값;


<br>

### ⬛ 배열 길이
- 배열의 길이 = 전체 항목의 개수
- 문법 : 배열변수.length;
- 배열의 length 필드는 for문을 사용해서 배열 전체를 루핑할 때 매우 유용하게 사용할 수 있다.


<br>

### ⬛ 다차원 배열
- 값들이 행과 열로서 구성된 배열을 2차원 배열이라고 한다.
<br>

- 자바는 2차원 배열을 중첩 배열 방식으로 구현한다.
    - ![image](https://user-images.githubusercontent.com/93142964/177894332-6fdf28fd-405c-4930-8a33-3661260cc6d6.png)
	    - scores.length     : 결과값 2
	    - scores[0].length   : 결과값 3
	    - scores[1].length   : 결과값 3

<br><br>
- 자바는 1차원 배열이 서로 연결된 구조로 다차원 배열을 구현하기 때문에, 수학 행렬 구조가 아닌 계단식 구조를 가질 수도 있다. 
    - ![image](https://user-images.githubusercontent.com/93142964/177894484-6d4c9568-78a4-47dd-936e-252a327dcb48.png)
        - scores.length     : 결과값 2
        - scores[0].length   : 결과값 2
        - scores[1].length   : 결과값 3
        - 이러한 형태의 배열을 배열의 정확한 길이를 알고 인덱스를 사용해야한다.
            - 없는 인덱스에 값을 집어 넣으면 ArrayIndexOutOfBoundsException을 발생시킨다.
        - 같은 형태를 중괄호로 표현하기 (중괄호 안의 중괄호 사용)
            - ![image](https://user-images.githubusercontent.com/93142964/177894570-1f301d6e-7888-4a42-bde1-d32777a14ca3.png)



<br><br>

### ⬛ 배열 복사
- 배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 더 큰 배열을 새로 만들고 이전 배열로부터 항목 값을 복사해야 한다.
<br>

- (방법1) for문 사용
    - ![image](https://user-images.githubusercontent.com/93142964/177894638-75711063-1f87-46f8-838a-146af8de3a99.png)
    	- 복사되지 않은 항목은 int[] 배열의 초기값인 0이 유지된다.

<br>

- (방법2) System.arraycopy() 메소드 사용
    - ![image](https://user-images.githubusercontent.com/93142964/177894774-e0af0f10-831e-4819-a725-4fb8a86e9bb5.png)
<br><br>

- ![image](https://user-images.githubusercontent.com/93142964/177894809-85c491fa-1cc9-4f20-b368-9141c91be2c6.png)
	- 복사되지 않은 항목은 String[] 배열의 초기값인 null이 그대로 유지된다.
	- 참조 타입 배열이 복사되면 복사되는 값이 객체의 번지이므로, 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일하다.














